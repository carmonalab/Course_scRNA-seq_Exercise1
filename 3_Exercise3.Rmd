---
title: "Exercise 1"
output: 
  html_document: 
    number_sections: true
    toc: true
---

# Exercise 3

# Goals

-   Try different packages to "integrate" (= combine and mitigate batch effect for) multiple datasets

# Introduction

In this exercise, you will compare the historically most commonly used integration method, called "Harmony". However, we will see it's limitation and how newer integration methods further improved on Harmony's limitation to mitigate batch effect.

```{r, message=FALSE, warning=F, results=FALSE}

# Load the environment and libraries
# install.packages("remotes")
# library(remotes)
# remotes::install_github("carmonalab/scGate",ref="7a3576d")
# remotes::install_github("carmonalab/SignatuR",ref="b1050ae32a600b986f14db236f8d45756aaee05b")
# remotes::install_github("carmonalab/STACAS",ref="05fa74d")
# remotes::install_github("carmonalab/scIntegrationMetrics")
library(Seurat)
library(scGate)
library(SignatuR)
library(STACAS)
library(scIntegrationMetrics)
library(ggplot2)
library(dplyr)
library(patchwork)
library(parallel)
library(harmony)

# devtools::install_github('satijalab/seurat-data')
library(SeuratData)
```

# Set paths

```{r}
my_seed <- 321
set.seed(my_seed)

root <- getwd()

path_data <- file.path(root, "data/Exercise3")
dir.create(file.path(path_data))
path_output <- file.path(root, "output/Exercise3")
dir.create(file.path(path_output))
path_plots <- file.path(root, "plots/Exercise3")
dir.create(file.path(path_plots))
```

# Load the data

```{r, fig.height=10, fig.width=10}
InstallData("panc8")
data("panc8")
panc8 <-  UpdateSeuratObject(object = panc8)

ndim <- 30
panc8 <- panc8 |> NormalizeData() |> FindVariableFeatures() |> ScaleData() |> RunPCA(npcs=ndim) |> RunUMAP(reduction = "pca", dims = 1:ndim, seed.use=my_seed)

p.list.Tcell <- list()
p.list.Tcell[[1]] <- DimPlot(panc8, label = T, repel = T, group.by = 'celltype')
p.list.Tcell[[2]] <- DimPlot(panc8, label = T, repel = T, group.by = 'tech')
p.list.Tcell[[3]] <- DimPlot(panc8, label = T, repel = T, group.by = 'dataset')
for (p in p.list.Tcell) {
  print(p)
}
wrap_plots(p.list.Tcell, ncol = 2) + theme(aspect.ratio = 1) + NoLegend()
```

-   What do you notice in the UMAP by celltype?

-   Have a look at the UMAP by sequencing technology. Can you explain why the same celltype forms multiple clusters?

-   Looking at the UMAP by dataset, what can you see when looking at the different datasets acquired with the inDrop technology? (the datasets called indrop1, indrop2, indrop3, indrop4 are acquired with the same technology)

# Apply Harmony batch correction

```{r}
panc8 <- RunHarmony(panc8, "tech")
panc8 <- RunUMAP(panc8, reduction = "harmony", dims = 1:ndim, seed.use=my_seed)
```

## Investigate the effect of Harmony batch correction

```{r, fig.height=10, fig.width=10}
p.list.Tcell <- list()
p.list.Tcell[[1]] <- DimPlot(panc8, label = T, repel = T, group.by = 'celltype')
p.list.Tcell[[2]] <- DimPlot(panc8, label = T, repel = T, group.by = 'tech')
p.list.Tcell[[3]] <- DimPlot(panc8, label = T, repel = T, group.by = 'dataset')
for (p in p.list.Tcell) {
  print(p)
}
wrap_plots(p.list.Tcell, ncol = 2) + theme(aspect.ratio = 1) + NoLegend()
```

-   Looking at the alpha cell cluster, what do you notice, regarding celltype and tech?
-   Are batches well mixed?
-   Is biological information retained well? (If we mix everything, of course batches are well mixed but celltypes should not be mixed!)
-   Do you think this is a good integration result?

# Apply STACAS batch correction

```{r}
panc8.list <- SplitObject(panc8, split.by = "tech")
panc8.stacas <- Run.STACAS(panc8.list)
panc8.stacas <- RunUMAP(panc8.stacas, reduction = "pca", dims = 1:ndim, seed.use=my_seed)
rm(panc8.list)
gc()
```

## Investigate the effect of STACAS batch correction

```{r, fig.height=10, fig.width=10}
p.list.Tcell <- list()
p.list.Tcell[[1]] <- DimPlot(panc8.stacas, label = T, repel = T, group.by = 'celltype')
p.list.Tcell[[2]] <- DimPlot(panc8.stacas, label = T, repel = T, group.by = 'tech')
p.list.Tcell[[3]] <- DimPlot(panc8.stacas, label = T, repel = T, group.by = 'dataset')
for (p in p.list.Tcell) {
  print(p)
}
wrap_plots(p.list.Tcell, ncol = 2) + theme(aspect.ratio = 1) + NoLegend()
```

Looking at the alpha celltype cluster again, compared to Harmony integration, STACAS did a better job at mixing datasets, as well as retaining the correct celltype in the correct cluster.

# Calculate integration metrics after batch correction

In Exercise 2, we calculated the average silhouette width per sample as a metric to investigate batch effect and mitigation thereof. Lets do that again here:

```{r}
# We create a subset of alpha cells from
panc8.alpha <- subset(panc8, subset = celltype == "alpha")
panc8.stacas.alpha <- subset(panc8.stacas, subset = celltype == "alpha")

Idents(panc8.alpha) <- "dataset"
Idents(panc8.stacas.alpha) <- "dataset"

# Define function to calculate silhouette widths
# INPUT:
# - Seurat object with dataset annotation stored in object$dataset
# - method.reduction (for Harmony integration, the data is stored in the same object as the non-integrated data)
# RETURNS: A list, containing:
# - plot: a silhouette plot
# - SilW_per_cell: Silhouette coefficient for each cell (Vector)
# - AvgSilW_per_sample: Average silhouette coefficient per sample (Vector)

calc_sil_widths <- function(object, method.reduction){
  return_list <- list()
  dist.matrix <- dist(Embeddings(object = object[[method.reduction]])[, 1:ndim])
  clusters <- object$dataset
  sil <- cluster::silhouette(as.numeric(as.factor(clusters)), dist = dist.matrix)
  object$sil <- sil[, "sil_width"]
  
  return_list[["plot"]] <- factoextra::fviz_silhouette(sil, print.summary = TRUE, ggtheme = theme_classic()) +
    scale_fill_discrete(labels = unique(object$dataset)) + guides(col="none")
  
  SilW_per_cell <- c()
  AvgSilW_per_dataset <- c()
  for (dataset in unique(object$dataset)) {
    dataset_cells_sils <- object$sil[which(object$dataset == dataset)]
    SilW_per_cell <- c(SilW_per_cell, dataset_cells_sils)
    AvgSilW_per_dataset <- c(AvgSilW_per_dataset, setNames(mean(dataset_cells_sils), dataset))
  }
  return_list[["SilW_per_cell"]] <- SilW_per_cell
  return_list[["AvgSilW_per_dataset"]] <- AvgSilW_per_dataset
  return(return_list)
}

# Lets have a look at the silhouette coefficients looking at only the samples from dataset 1
panc8.alpha.sil_list <- calc_sil_widths(panc8.alpha, "pca")
print(panc8.alpha.sil_list$plot)

panc8.alpha.sil_list <- calc_sil_widths(panc8.alpha, "harmony")
print(panc8.alpha.sil_list$plot)

panc8.stacas.alpha.sil_list <- calc_sil_widths(panc8.stacas.alpha, "pca")
print(panc8.stacas.alpha.sil_list$plot)
```

Again, we can see that before correcting for batch effect, the samples cluster strongly by dataset. The average silhouette width is very high. Harmony does a good job at mitigating batch effect. However, "indrop1" still seems to show batch effect and is not very well integrated. STACAS does an even slightly better job, as "indrop1" and "indrop2" show clearly lower overall silhouette scores.

# ℹ️ Exercise

Silhouette score is a metric to evaluate batch mixing.

However, as we have seen above, we also need to check that celltypes were not overly mixed. I.e. each cell should be closest to the celltype cluster it belongs.

## Cluster purity evaluation

UMAP distances are not quantitative, as they are derived in a very non-linear way. For simplicity, let us look at how many cells are clustered to their corresponding celltype cluster in the UMAP. After that, you will see a more sophisticated method to check whether cells are in their correct neighbourhood, called iLISI.

-   Cluster the cells in both batch corrected objects (make sure that all cells close to the alpha cluster are assigned to the one same cluster. Do not care about the other clusters for the sake of simplicity)
-   Calculate the fraction of alpha cells vs non-alpha-cells in the alpha cluster for both objects
-   Calculate the fraction of alpha cells in the alpha cluster vs the sum of all cells annotated as alpha cells (celltype in the metadata)

```{r}
# Enter code here

# Suggested functions:
# - FindNeighbors(object, reduction = "harmony", dims = 1:ndim) /// FindNeighbors(object, reduction = "pca", dims = 1:ndim)
# - FindClusters(object, resolution = X) /// try some different X inputs for the resolution, e.g. some number between 0.01 and 3
# - DimPlot(object, label = T, repel = T, group.by = 'seurat_clusters')
# - table(object$celltype[panc8$RNA_snn_res.X == cluster.number]) /// put the respective cluster.number from the UMAP for the alpha cell cluster







```

# Alternative integration metrics

We have seen that the batch mixing and celltype cluster retention (mitigating technical artefact while retaining biological information) are two critical aspects to evaluate the quality of an integration method. The scIntegrationMetrics package provides a convenient function to do this.

Lets look at two of the integrations metrics: - iLISI: Local Inverse Simpson's Index (LISI) for batch mixing, as defined by [Korsunsky et al. Nat Methods (2019)](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6884693); it quantifies the effective number of datasets in a local neighborhood, thereby measuring batch mixing. (higher = better batch mixing) - celltype_ASW: Average Silhouette Width by celltype: it quantifies distances of cells of the same type compared to the distances to cells of other types. (higher = more well-separated and/or denser celltype clusters)

Explanations for the other integration metrics you can find on the [scIntegrationMetrics GitHub repository](https://github.com/carmonalab/scIntegrationMetrics)

```{r}
metrics <- getIntegrationMetrics(panc8, method.reduction = "pca", meta.label = "celltype",
                                 meta.batch = "tech",
                                 iLISI_perplexity = 20)
unlist(metrics)

metrics <- getIntegrationMetrics(panc8, method.reduction = "harmony", meta.label = "celltype",
                                 meta.batch = "tech",
                                 iLISI_perplexity = 20)
unlist(metrics)

metrics <- getIntegrationMetrics(panc8.stacas, method.reduction = "pca", meta.label = "celltype",
                                 meta.batch = "tech",
                                 iLISI_perplexity = 20)
unlist(metrics)
```

# \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\--

# Solution

```{r}
panc8 <- FindNeighbors(panc8, reduction = "harmony", dims = 1:ndim)
panc8 <- FindClusters(panc8, resolution = 0.05)
DimPlot(panc8, label = T, repel = T, group.by = 'seurat_clusters')

panc8.stacas <- FindNeighbors(panc8.stacas, dims = 1:ndim)
panc8.stacas <- FindClusters(panc8.stacas, resolution = 0.05)
DimPlot(panc8.stacas, label = T, repel = T, group.by = 'seurat_clusters')

# Example true labels and predicted clusters (replace these with your own data)
alpha_cluster.harmony <- table(panc8$celltype[panc8$RNA_snn_res.0.05 == 0])
alpha_cluster.stacas <- table(panc8.stacas$celltype[panc8.stacas$integrated_snn_res.0.05 == 0])

alpha_cluster.harmony["alpha"] / sum(alpha_cluster.harmony)
alpha_cluster.stacas["alpha"] / sum(alpha_cluster.stacas)

alpha_cluster.harmony["alpha"] / length(panc8$celltype[panc8$celltype == "alpha"])
alpha_cluster.stacas["alpha"] / length(panc8.stacas$celltype[panc8.stacas$celltype == "alpha"])
```
