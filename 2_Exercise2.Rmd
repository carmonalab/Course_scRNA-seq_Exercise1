---
title: "Exercise 1"
output: 
  html_document: 
    number_sections: true
    toc: true
---

# Exercise 2

# Goals

-   Apply what you learnt in Exercise 1

-   Go big, automation makes it possible!\
    -\> Use an R package for automated cell annotation across multiple samples in *one* dataset

-   Combine multiple datasets

    -   Learn about batch effect

    -   Quantify batch effect

# Introduction

In the second exercise, you will apply what you learnt in exercise 1 to annotate the celltypes in a breast cancer dataset (which you have seen shortly seen at the end of the Gfeller part of this course)

```{r, message=FALSE, warning=F, results=FALSE}

# Load the environment and libraries
# remotes::install_github("carmonalab/scGate",ref="7a3576d")
# remotes::install_github("carmonalab/SignatuR",ref="b1050ae32a600b986f14db236f8d45756aaee05b")
# remotes::install_github("carmonalab/STACAS",ref="05fa74d")
library(Seurat)
library(scGate)
library(SignatuR)
library(STACAS)
library(ggplot2)
library(dplyr)
library(patchwork)
library(parallel)
```

# Set paths

```{r}
my_seed <- 321
set.seed(my_seed)

root <- getwd()

path_data <- file.path(root, "data/Exercise2")
dir.create(file.path(path_data))
path_output <- file.path(root, "output/Exercise2")
dir.create(file.path(path_output))
path_plots <- file.path(root, "plots/Exercise2")
dir.create(file.path(path_plots))
```

# Load the data

## Download the data

If not done before

```{r}
# Download the Peripheral Blood Mononuclear Cells (PBMC) dataset
destfile <- file.path(path_data, "Archive.zip")
if (!exists(destfile)) {
  download.file(url = "https://www.dropbox.com/scl/fi/frnqtdn97ybw2s8g2k9xj/Archive.zip?rlkey=5zx2i97nzvce98snjsq77ta56&dl=1",
              destfile = destfile)
  # Decompress file
  unzip(destfile, exdir = path_data)
}
rm(destfile)
```

## Load data and create a Seurat object

```{r, message=FALSE, warning=F}
brca.data = Read10X(file.path(path_data))

# Initialize the Seurat object with the raw (non-normalized data).
obj <- CreateSeuratObject(counts = brca.data, project = "brca",
                          min.cells = 3, min.features = 200)

# For the sake of speed and RAM memory availability in some laptops, we use just a small part of the dataset for this exercise
obj <- subset(obj, downsample=500)
obj

rm(brca.data)
gc()
```

# QC and pre-processing

## Quality control (QC)

```{r paged.print=FALSE}
# The [[ operator can add columns to object metadata. This is a great place to stash QC stats
obj[["percent.mt"]] <- PercentageFeatureSet(obj, pattern = "^MT-")

# Show QC metrics for the first 5 cells
head(obj@meta.data, 5)
```

In the example below, we visualize QC metrics, and use these to filter cells.

```{r, fig.width = 10}
# Visualize QC metrics as a violin plot
VlnPlot(obj, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3)
VlnPlot(obj, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3, pt.size = 0) # remove points to see distribution better

# FeatureScatter is typically used to visualize feature-feature relationships, but can be used for anything calculated by the object, i.e. columns in object metadata, PC scores etc.
plot1 <- FeatureScatter(obj, feature1 = "nCount_RNA", feature2 = "percent.mt") & NoLegend()
plot2 <- FeatureScatter(obj, feature1 = "nCount_RNA", feature2 = "nFeature_RNA") & NoLegend()
plot1 + plot2
rm(plot1, plot2)
```

## How many cells per sample?

```{r}
sample.size.pre <- sort(table(obj$orig.ident))
sample.size.pre
barplot(sort(sample.size.pre), las=2)
```

## ℹ️ Exercise

### Select appropriate QC metrics

-   Adjust and select appropriate nFeature_RNA upper threshold

-   Adjust and select appropriate percent.mt threshold

```{r warning=FALSE}
# Seurat plots can be easily modified with the popular ggplots2 library by chaining it with the "&" operator
thresh_nFeature_RNA <- c(200, 5000)
thresh_percent.mt <- 17

plot1 <- VlnPlot(obj, features = "nFeature_RNA", pt.size = 0) &
  geom_hline(yintercept = thresh_nFeature_RNA, linetype='dashed', col = 'red') & NoLegend()
plot2 <- VlnPlot(obj, features = "nCount_RNA", pt.size = 0) & NoLegend()
plot3 <- VlnPlot(obj, features = "percent.mt", pt.size = 0) &
  geom_hline(yintercept = thresh_percent.mt, linetype='dashed', col = 'red') & NoLegend()
patchwork::wrap_plots(plot1, plot2, plot3, ncol = 3)
rm(plot1, plot2, plot3)
```

## Subset to filter out low quality cells

```{r warning=FALSE}
# Subset data according to our filter creteria
obj <- subset(obj,
              subset =
                nFeature_RNA > thresh_nFeature_RNA[1] &
                nFeature_RNA < thresh_nFeature_RNA[2] &
                percent.mt < thresh_percent.mt)

VlnPlot(obj, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3, pt.size = 0)
plot1 <- FeatureScatter(obj, feature1 = "nCount_RNA", feature2 = "percent.mt") & NoLegend()
plot2 <- FeatureScatter(obj, feature1 = "nCount_RNA", feature2 = "nFeature_RNA") & NoLegend()
plot1 + plot2
rm(plot1, plot2)
```

## How many cells per sample after QC?

```{r}
sample.size <- table(obj$orig.ident)[names(sample.size.pre)]
sample.size
barplot(sort(sample.size), las=2)
sample.size.filterRatio <- round((sample.size.pre - sample.size)/sample.size.pre*100,2)
sample.size.filterRatio
barplot(sample.size.filterRatio[names(sort(sample.size))], las=2)
```

## Save quality-controlled dataset

```{r}
saveRDS(obj, file.path(path_output, "exercise2_QCed.rds"), compress = FALSE) # compress = FALSE takes more disk space but makes saving and loading a lot faster
```

# Automated cell type annotation

In the previous exercise you annotated clusters of cells manually. You did so by checking which genes are most highly expressed in a cluster and prefereably not in all others, i.e. which specific gene expression characterizes your cell type of interest. As this is very tedious and repetitive, many tools have been developed to automate this process. The basic principle is the same: cell types are characterized by a specific gene expression pattern. Some tools use single genes or a small set of highly specific expression markers. Other tools use extensive sets of genes, called "signatures".

However, each method comes with its own advantages, limitations and drawbacks. For example, on one hand, some annotation tools can annotate a wide range of cell types across many tissues but lack the resolution to annotate subtypes. On the other hand, some packages are highly focused on a specific cell type but can go very deep and are able to very accurately annotate them and their subtypes at high-resolution.

In this exercise, you will apply [scGate](https://github.com/carmonalab/scGate), an R package that automatizes the typical manual marker-based approach to cell type annotation, to enable accurate and intuitive purification of a cell population, without requiring reference gene expression profiles or training data. It's mostly focused on immune cells and other cell types found in cancer.

scGate uses a [database of expert-selected markers](https://github.com/carmonalab/scGate_models/blob/master/human/generic/master_table.tsv) and hierarchical gating. For example, you identify immune cells as CD45+. However, immune cells can be further sub-classified into e.g. CD45+CD8+ cells and others that are CD45+CD8-. B cells for example are CD45+CD8-CD20+ and so on.

Hierarchical gating is very good if you have very clear binary markers that are either positive/negative. But what if you have gradients of gene expression levels? Or if you go very deep: if you want to look at different CD8 subtypes? At some point, you will run out of markers that are distinctly positive/negative. In this case, gene expression profiles can be very useful for further refinement (e.g. [this tool](https://github.com/carmonalab/ProjecTILs)).

![](images/scGate_hierarchical_gating.png)

## Run scGate models to annotate cell types

### Select scGate models (cell types)

```{r, fig.width=10, fig.height=10}
#Get scGate database of pre-defined gating models
scGate_models_DB <- get_scGateDB(branch = "master", verbose = T, force_update = TRUE)
models.TME <- scGate_models_DB$human$TME_HiRes
```

### Run scGate

We run scGate on single samples to prevent batch effects between samples. So, we split the object into a list of objects, one for each sample

We will then find the highly variable features for each sample separately and then combine the ones that are consistently found variable across all samples. This is in order to prevent a bias if all variable features would be selected from only one or a few samples.

Additionally, we want to exclude variable genes like cell cycle genes that might be variable for each cell type (at some point in time) but do not contribute to distinguish BETWEEN cell types. Also genes like heat-shock proteins might vary, depending on cell stress, or immunoglobulin or TCR for immune cells but are not helpful to distinguish BETWEEN cell types.

```{r}
# Split object into list of objects (by sample)
Idents(obj) <- "orig.ident"
obj.list <- SplitObject(obj)

# To speed things up, we only keep the first 5 samples for further analysis
obj.list <- obj.list[1:5]

cache_filename <- file.path(path_output,"exercise2_scGate_annotated_list.rds")

nfeatures <- 2000
ndim <- 30
my.genes.blocklist <- GetSignature(SignatuR$Hs)[c("Pseudogenes", "HSP", "Non-coding", "cellCycle.G1S", "cellCycle.G2M", "Mito", "Ribo", "TCR", "Immunoglobulins")]

# As the cell annotation takes some time, we use the full power of  our modern CPUs having multiple cores
# We run the calculation in a parallel for-loop, meaning we process several samples at once, distributed across CPU cores, one sample per core
# For long calculation steps, it is advisable to save them afterwards, so we can just reload from this step later without needing to re-process everything
if (file.exists(cache_filename)) {
  obj.list <- readRDS(cache_filename)
} else {
  ncores <- parallel::detectCores()
  for (sample in names(obj.list)) {
    obj.list[[sample]] <- NormalizeData(obj.list[[sample]])
    obj.list[[sample]] <- scGate(obj.list[[sample]], model=models.TME, ncores = ncores-1)
    obj.list[[sample]] <- FindVariableFeatures.STACAS(obj.list[[sample]], nfeat=nfeatures*2, genesBlockList=my.genes.blocklist)
    # here we ask for *2 variable features, and then we'll select those nfeatures that are consistently variable across datasets
    obj.list[[sample]] <- ScaleData(obj.list[[sample]])
    obj.list[[sample]] <- RunPCA(obj.list[[sample]], ndims.print = 1:5, nfeatures.print = 5)
    obj.list[[sample]] <- RunUMAP(obj.list[[sample]], reduction = "pca", dims = 1:ndim, seed.use=my_seed)
  }
  saveRDS(obj.list, cache_filename)
}
```

```{r}
pll.s <- list()
for (sample in names(obj.list)){
  (length(table(obj.list[[sample]]$scGate_multi)) == 0) && next
  pll.s[[sample]] <- DimPlot(obj.list[[sample]], reduction = "umap", group.by = "scGate_multi", label=T, raster = FALSE ) + theme(aspect.ratio=1) + ggtitle(sample)
}
pll.s.w <- wrap_plots(pll.s)
ggsave(plot = pll.s.w, file.path(path_plots,"UMAP_scGate_broad_classification_perSample.png"),width = 20, height = 20, limitsize = F)

rm(pll.s, pll.s.w)
gc()
```

## Merge list of objects back into one object

```{r, fig.width=10, fig.height=10}
obj <- merge(obj.list[[1]],obj.list[2:length(obj.list)])

obj@misc$batch.metadata <- obj.list[[1]]@misc$batch.metadata
hvg <- SelectIntegrationFeatures(obj.list, nfeatures = nfeatures) # we obtained highly variable genes that are consistent across samples
obj@assays$RNA@var.features <- hvg

rm(obj.list)
gc()
```

# Run pre-processing on complete obj

```{r}
obj <- obj |> NormalizeData() |> ScaleData() |> RunPCA(npcs=ndim) |> RunUMAP(dims = 1:ndim)
saveRDS(obj, file.path(path_output,"exercise2_processed_obj.rds"))
```

# Plot UMAP

```{r}
DimPlot(obj, reduction = "umap", group.by = "orig.ident") + theme(aspect.ratio=1)
ggsave(file.path(path_plots,"UMAP_full_by_sample.png"), width = 10, height = 10)
DimPlot(obj, reduction = "umap", group.by = "scGate_multi", label = TRUE) + theme(aspect.ratio=1)
ggsave(file.path(path_plots,"UMAP_full_by_annotation.png"), width = 10, height = 10)
```

# Visualize the expression of some genes

```{r, fig.height=20, fig.width=20}
myFeatures <- c("PTPRC","CD2","FOXP3","CD4","CD8A","SPI1","CD79A","MKI67","COL1A1","FCER1G","APOE","C1QB","MS4A1","RGS13","CSF3R","KLRD1","S100A9","S100A8") # just to explore
FeaturePlot(obj, reduction = "umap", features = myFeatures, coord.fixed=T, ncol=5, order = T) 
ggsave(file.path(path_plots,"UMAP_features.png"),width = 40, height = 30)
```

# Check for batch effects

```{r fig.height=10, fig.width=10}
# Remove obj from RAM memory
rm(obj)
gc()

# Load obj.list from above
obj.list <- readRDS(cache_filename)

# Download data
download.file("https://www.dropbox.com/scl/fi/zrf8v74tytw94lm1ex1j6/samples_from_other_studies.rds?rlkey=4yg1magn4utn9ohxr10np2pq0&dl=1",
              file.path(path_data, "samples_from_other_studies.rds"))
samples_from_other_studies <- readRDS(file.path(path_data, "samples_from_other_studies.rds"))

obj.list.multi_study <- c(obj.list, samples_from_other_studies)
rm(obj.list, samples_from_other_studies)
gc()

hvg <- SelectIntegrationFeatures(obj.list.multi_study, nfeatures = nfeatures) # we obtained highly variable genes that are consistent across samples

obj.multi_study <- merge(obj.list.multi_study[[1]], obj.list.multi_study[2:length(obj.list.multi_study)])
obj.multi_study@assays$RNA@var.features <- hvg
rm(obj.list.multi_study)
gc()

obj.multi_study <- obj.multi_study |> NormalizeData() |> ScaleData() |> RunPCA(npcs=ndim) |> RunUMAP(dims = 1:ndim)

DimPlot(obj.multi_study, reduction = "umap", group.by = "scGate_multi", label = TRUE) + theme(aspect.ratio=1)
DimPlot(obj.multi_study, reduction = "umap", group.by = "orig.ident") + theme(aspect.ratio=1)
```

Looking at the CD4T cluster(s) in the above UMAP, it seems that the CD4 T cells from the initial dataset (orig.ident sample names starting with "sc5r") cluster together and are mixed. However, there are two distinct separate clusters of CD4 cells for the "study1_sample" and "study2_sample", respectively. Is it likely that these patients show completly different and unique CD4 T cells cell types? The "study1_sample", like the "sc5r" samples, stems from a breast tumor sample. The "study2_sample", stems from a head and neck squamous cell carcinoma (HNSCC) tumor sample.

There might be some specific CD4 T cell subtypes in a different tissue/cancer but it is unlikely that all CD4 T cells from these other study samples are COMPLETELY different. After all, we all share the same CD4 T cells and subtypes. So, at least for the "study1_sample" (given that the treatment was similar) the cells should be well mixed...but they are not! Why?

"Single-cell data is often compiled from multiple experiments with differences in capturing times, handling personnel, reagent lots, equipments, and even technology platforms. These differences lead to large variations or batch effects in the data, and can confound biological variations of interest during data integration. As such, effective batch-effect removal is essential. Batch effects can be highly nonlinear, making it difficult to correctly align different datasets while preserving key biological variations" ([Tran et al. 2020](https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1850-9#:~:text=Batch%20effects%20can%20be%20highly,(scRNA%2Dseq)%20data.)).

For this reason, several different tools have been developped trying to address this problem. You will learn about two of them in exercise 3. For now, lets try to find a suitable metric to quantify this batch effect, in order to later quantify to what degree we can mitigate it.

## ℹ️ Exercise

### Quantify the batch effect in CD4 T cells

```{r}
obj.CD4T.multi <- subset(obj.multi_study, subset = scGate_multi == "CD4T")
obj.CD4T <- subset(obj.CD4T.multi, subset = orig.ident %in% unique(obj.multi_study@meta.data[["orig.ident"]])[1:5])

obj.CD4T <- obj.CD4T |> NormalizeData() |> FindVariableFeatures() |> ScaleData() |> RunPCA(npcs=30) |> RunUMAP(dims = 1:30)
DimPlot(obj.CD4T, reduction = "pca", group.by = "orig.ident") + theme(aspect.ratio=1)

obj.CD4T.multi <- obj.CD4T.multi |> NormalizeData() |> FindVariableFeatures() |> ScaleData() |> RunPCA(npcs=30) |> RunUMAP(dims = 1:30)
DimPlot(obj.CD4T.multi, reduction = "pca", group.by = "orig.ident") + theme(aspect.ratio=1)
```

-   What can you observe in the above PCA plots

    -   The first PCA biplot shows only samples from the same "sc5r" dataset

    -   The second PCA biplot shows samples from all three datasets together

-   Calculate the average silhouette score (from samples) from the "sc5r" dataset

    -   Create a silhouette plot, e.g. using\
        factoextra::fviz_silhouette(sil, ggtheme = theme_classic())

-   Calculate the average silhouette score (from samples) from all three datasets together

```{r}
Idents(obj.CD4T) <- "orig.ident"
dist.matrix <- dist(Embeddings(object = obj.CD4T[["pca"]])[, 1:ndim])
clusters <- obj.CD4T$orig.ident
sil <- cluster::silhouette(as.numeric(as.factor(clusters)), dist = dist.matrix)
obj.CD4T$sil <- sil[, "sil_width"]

sample_sil_single_study <- c()
for (sample in unique(obj.CD4T$orig.ident)) {
  a <- mean(obj.CD4T$sil[which(obj.CD4T$orig.ident == sample)])
  sample_sil_single_study <- append(sample_sil_single_study, a)
}
sample_sil_single_study <- setNames(sample_sil_single_study, unique(obj.CD4T$orig.ident)) 
sample_sil_single_study
mean(sample_sil_single_study)

factoextra::fviz_silhouette(sil, ggtheme = theme_classic())

Idents(obj.CD4T.multi) <- "orig.ident"
dist.matrix <- dist(Embeddings(object = obj.CD4T.multi[["pca"]])[, 1:ndim])
clusters <- obj.CD4T.multi$orig.ident
sil <- cluster::silhouette(as.numeric(as.factor(clusters)), dist = dist.matrix)
obj.CD4T.multi$sil <- sil[, "sil_width"]

sample_sil_multi_study <- c()
for (sample in unique(obj.CD4T.multi$orig.ident)) {
  a <- mean(obj.CD4T.multi$sil[which(obj.CD4T.multi$orig.ident == sample)])
  sample_sil_multi_study <- append(sample_sil_multi_study, a)
}
sample_sil_multi_study <- setNames(sample_sil_multi_study, unique(obj.CD4T.multi$orig.ident)) 
sample_sil_multi_study
mean(sample_sil_multi_study)

factoextra::fviz_silhouette(sil, ggtheme = theme_classic(), print.summary = TRUE)
```
